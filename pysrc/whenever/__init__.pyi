import enum
from abc import ABC
from collections.abc import Iterator
from contextlib import contextmanager
from datetime import (
    date as _date,
    datetime as _datetime,
    time as _time,
    timedelta as _timedelta,
)
from typing import Any, ClassVar, Literal, TypeAlias, final, overload
from typing_extensions import Self

__all__ = [
    "Date",
    "Time",
    "Instant",
    "OffsetDateTime",
    "ZonedDateTime",
    "SystemDateTime",
    "LocalDateTime",
    "DateDelta",
    "TimeDelta",
    "DateTimeDelta",
    "years",
    "months",
    "weeks",
    "days",
    "hours",
    "minutes",
    "seconds",
    "microseconds",
    "SkippedTime",
    "RepeatedTime",
    "InvalidOffset",
    "MONDAY",
    "TUESDAY",
    "WEDNESDAY",
    "THURSDAY",
    "FRIDAY",
    "SATURDAY",
    "SUNDAY",
]

_EXTENSION_LOADED: bool
__version__: str

_RoundUnitTime: TypeAlias = Literal[
    "hour",
    "minute",
    "second",
    "millisecond",
    "microsecond",
    "nanosecond",
]
_RoundUnitDate: TypeAlias = Literal["day", _RoundUnitTime]
_RoundMode: TypeAlias = Literal[
    "ceil",
    "floor",
    "half_ceil",
    "half_floor",
    "half_even",
]
_Disambiguate: TypeAlias = Literal["compatible", "raise", "earlier", "later"]

@final
class Date:
    def __init__(self, year: int, month: int, day: int) -> None: ...
    MIN: ClassVar[Self]
    MAX: ClassVar[Self]
    @staticmethod
    def today_in_system_tz() -> Self: ...
    @property
    def year(self) -> int: ...
    @property
    def month(self) -> int: ...
    @property
    def day(self) -> int: ...
    def year_month(self) -> YearMonth: ...
    def month_day(self) -> MonthDay: ...
    def day_of_week(self) -> Weekday: ...
    def at(self, t: Time, /) -> LocalDateTime: ...
    def py_date(self) -> _date: ...
    @classmethod
    def from_py_date(cls, d: _date, /) -> Self: ...
    def format_common_iso(self) -> str: ...
    @classmethod
    def parse_common_iso(cls, s: str, /) -> Self: ...
    def replace(
        self, *, year: int = ..., month: int = ..., day: int = ...
    ) -> Self: ...
    @overload
    def add(
        self, *, years: int = 0, months: int = 0, weeks: int = 0, days: int = 0
    ) -> Self: ...
    @overload
    def add(self, delta: DateDelta, /) -> Self: ...
    @overload
    def subtract(
        self, *, years: int = 0, months: int = 0, weeks: int = 0, days: int = 0
    ) -> Self: ...
    @overload
    def subtract(self, delta: DateDelta, /) -> Self: ...
    def days_since(self, other: Self, /) -> int: ...
    def days_until(self, other: Self, /) -> int: ...
    def __add__(self, p: DateDelta, /) -> Self: ...
    @overload
    def __sub__(self, d: DateDelta, /) -> Self: ...
    @overload
    def __sub__(self, d: Self, /) -> DateDelta: ...
    def __lt__(self, other: Self, /) -> bool: ...
    def __le__(self, other: Self, /) -> bool: ...
    def __gt__(self, other: Self, /) -> bool: ...
    def __ge__(self, other: Self, /) -> bool: ...

@final
class YearMonth:
    def __init__(self, year: int, month: int) -> None: ...
    MIN: ClassVar[Self]
    MAX: ClassVar[Self]
    @property
    def year(self) -> int: ...
    @property
    def month(self) -> int: ...
    def format_common_iso(self) -> str: ...
    @classmethod
    def parse_common_iso(cls, s: str, /) -> Self: ...
    def replace(self, /, *, year: int = ..., month: int = ...) -> Self: ...
    def on_day(self, day: int, /) -> Date: ...
    def __lt__(self, other: Self, /) -> bool: ...
    def __le__(self, other: Self, /) -> bool: ...
    def __gt__(self, other: Self, /) -> bool: ...
    def __ge__(self, other: Self, /) -> bool: ...

@final
class MonthDay:
    def __init__(self, month: int, day: int) -> None: ...
    MIN: ClassVar[Self]
    MAX: ClassVar[Self]
    @property
    def month(self) -> int: ...
    @property
    def day(self) -> int: ...
    def format_common_iso(self) -> str: ...
    @classmethod
    def parse_common_iso(cls, s: str, /) -> Self: ...
    def replace(self, *, month: int = ..., day: int = ...) -> Self: ...
    def in_year(self, year: int, /) -> Date: ...
    def is_leap(self) -> bool: ...
    def __lt__(self, other: Self, /) -> bool: ...
    def __le__(self, other: Self, /) -> bool: ...
    def __gt__(self, other: Self, /) -> bool: ...
    def __ge__(self, other: Self, /) -> bool: ...

@final
class Time:
    def __init__(
        self,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        *,
        nanosecond: int = 0,
    ) -> None: ...
    MIDNIGHT: ClassVar[Self]
    NOON: ClassVar[Self]
    MAX: ClassVar[Self]
    @property
    def hour(self) -> int: ...
    @property
    def minute(self) -> int: ...
    @property
    def second(self) -> int: ...
    @property
    def nanosecond(self) -> int: ...
    def on(self, d: Date, /) -> LocalDateTime: ...
    def py_time(self) -> _time: ...
    @classmethod
    def from_py_time(cls, t: _time, /) -> Self: ...
    def format_common_iso(self) -> str: ...
    @classmethod
    def parse_common_iso(cls, s: str, /) -> Self: ...
    def replace(
        self,
        *,
        hour: int = ...,
        minute: int = ...,
        second: int = ...,
        nanosecond: int = ...,
    ) -> Self: ...
    def round(
        self,
        unit: _RoundUnitTime = "second",
        increment: int = 1,
        mode: _RoundMode = "half_even",
    ) -> Self: ...
    def __lt__(self, other: Self, /) -> bool: ...
    def __le__(self, other: Self, /) -> bool: ...
    def __gt__(self, other: Self, /) -> bool: ...
    def __ge__(self, other: Self, /) -> bool: ...

@final
class TimeDelta:
    def __init__(
        self,
        *,
        hours: float = 0,
        minutes: float = 0,
        seconds: float = 0,
        milliseconds: float = 0,
        microseconds: float = 0,
        nanoseconds: int = 0,
    ) -> None: ...
    ZERO: ClassVar[Self]
    MAX: ClassVar[Self]
    MIN: ClassVar[Self]
    def in_days_of_24h(self) -> float: ...
    def in_hours(self) -> float: ...
    def in_minutes(self) -> float: ...
    def in_seconds(self) -> float: ...
    def in_milliseconds(self) -> float: ...
    def in_microseconds(self) -> float: ...
    def in_nanoseconds(self) -> int: ...
    def in_hrs_mins_secs_nanos(self) -> tuple[int, int, int, int]: ...
    def py_timedelta(self) -> _timedelta: ...
    @classmethod
    def from_py_timedelta(cls, td: _timedelta, /) -> Self: ...
    def format_common_iso(self) -> str: ...
    @classmethod
    def parse_common_iso(cls, s: str, /) -> Self: ...
    def round(
        self,
        unit: _RoundUnitTime = "second",
        increment: int = 1,
        mode: _RoundMode = "half_even",
    ) -> Self: ...
    def __lt__(self, other: Self, /) -> bool: ...
    def __le__(self, other: Self, /) -> bool: ...
    def __gt__(self, other: Self, /) -> bool: ...
    def __ge__(self, other: Self, /) -> bool: ...
    def __bool__(self) -> bool: ...
    def __add__(self, other: Self, /) -> Self: ...
    def __sub__(self, other: Self, /) -> Self: ...
    def __mul__(self, other: float, /) -> Self: ...
    def __rmul__(self, other: float, /) -> Self: ...
    @overload
    def __truediv__(self, other: float, /) -> Self: ...
    @overload
    def __truediv__(self, other: Self, /) -> float: ...
    def __floordiv__(self, other: Self, /) -> int: ...
    def __mod__(self, other: Self, /) -> Self: ...
    def __neg__(self) -> Self: ...
    def __pos__(self) -> Self: ...
    def __abs__(self) -> Self: ...

@final
class DateDelta:
    ZERO: ClassVar[Self]
    def __init__(
        self, *, years: int = 0, months: int = 0, weeks: int = 0, days: int = 0
    ) -> None: ...
    def in_months_days(self) -> tuple[int, int]: ...
    def in_years_months_days(self) -> tuple[int, int, int]: ...
    def format_common_iso(self) -> str: ...
    @classmethod
    def parse_common_iso(cls, s: str, /) -> Self: ...
    def __bool__(self) -> bool: ...
    def __mul__(self, other: int, /) -> DateDeSelflta: ...
    def __rmul__(self, other: int, /) -> Self: ...
    @overload
    def __add__(self, other: Self, /) -> Self: ...
    @overload
    def __add__(self, other: TimeDelta, /) -> DateTimeDelta: ...
    def __radd__(self, other: TimeDelta, /) -> DateTimeDelta: ...
    @overload
    def __sub__(self, other: Self, /) -> Self: ...
    @overload
    def __sub__(self, other: TimeDelta, /) -> DateTimeDelta: ...
    def __rsub__(self, other: TimeDelta, /) -> DateTimeDelta: ...
    def __neg__(self) -> Self: ...
    def __pos__(self) -> Self: ...
    def __abs__(self) -> Self: ...

@final
class DateTimeDelta:
    def __init__(
        self,
        *,
        years: int = 0,
        months: int = 0,
        weeks: int = 0,
        days: int = 0,
        hours: float = 0,
        minutes: float = 0,
        seconds: float = 0,
        milliseconds: float = 0,
        microseconds: float = 0,
        nanoseconds: int = 0,
    ) -> None: ...
    ZERO: ClassVar[Self]
    def date_part(self) -> DateDelta: ...
    def time_part(self) -> TimeDelta: ...
    def in_months_days_secs_nanos(self) -> tuple[int, int, int, int]: ...
    def format_common_iso(self) -> str: ...
    @classmethod
    def parse_common_iso(cls, s: str, /) -> Self: ...
    def __bool__(self) -> bool: ...
    def __add__(self, other: Delta, /) -> Self: ...
    def __radd__(self, other: TimeDelta | DateDelta, /) -> Self: ...
    def __sub__(self, other: Delta, /) -> Self: ...
    def __rsub__(self, other: TimeDelta | DateDelta, /) -> Self: ...
    def __mul__(self, other: int, /) -> Self: ...
    def __rmul__(self, other: int, /) -> Self: ...
    def __neg__(self) -> Self: ...
    def __pos__(self) -> Self: ...
    def __abs__(self) -> Self: ...

Delta: TypeAlias = DateTimeDelta | TimeDelta | DateDelta

class _KnowsLocal(ABC):
    @property
    def year(self) -> int: ...
    @property
    def month(self) -> int: ...
    @property
    def day(self) -> int: ...
    @property
    def hour(self) -> int: ...
    @property
    def minute(self) -> int: ...
    @property
    def second(self) -> int: ...
    @property
    def nanosecond(self) -> int: ...
    def date(self) -> Date: ...
    def time(self) -> Time: ...

class _KnowsInstant(ABC):
    def timestamp(self) -> int: ...
    def timestamp_millis(self) -> int: ...
    def timestamp_nanos(self) -> int: ...
    @overload
    def to_fixed_offset(self, /) -> OffsetDateTime: ...
    @overload
    def to_fixed_offset(
        self, offset: int | TimeDelta, /
    ) -> OffsetDateTime: ...
    def to_tz(self, tz: str, /) -> ZonedDateTime: ...
    def to_system_tz(self) -> SystemDateTime: ...
    def difference(self, other: _KnowsInstant, /) -> TimeDelta: ...
    def __lt__(self, other: _KnowsInstant, /) -> bool: ...
    def __le__(self, other: _KnowsInstant, /) -> bool: ...
    def __gt__(self, other: _KnowsInstant, /) -> bool: ...
    def __ge__(self, other: _KnowsInstant, /) -> bool: ...

class _KnowsInstantAndLocal(_KnowsInstant, _KnowsLocal, ABC):
    def instant(self) -> Instant: ...
    def local(self) -> LocalDateTime: ...
    @property
    def offset(self) -> TimeDelta: ...

@final
class Instant(_KnowsInstant):
    @classmethod
    def from_utc(
        cls,
        year: int,
        month: int,
        day: int,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        *,
        nanosecond: int = 0,
    ) -> Self: ...
    MIN: ClassVar[Self]
    MAX: ClassVar[Self]
    @classmethod
    def now(cls) -> Self: ...
    @classmethod
    def from_timestamp(cls, i: int | float, /) -> Self: ...
    @classmethod
    def from_timestamp_millis(cls, i: int, /) -> Self: ...
    @classmethod
    def from_timestamp_nanos(cls, i: int, /) -> Self: ...
    @classmethod
    def from_py_datetime(cls, d: _datetime, /) -> Self: ...
    def py_datetime(self) -> _datetime: ...
    def format_rfc2822(self) -> str: ...
    @classmethod
    def parse_rfc2822(cls, s: str, /) -> Self: ...
    def format_rfc3339(self) -> str: ...
    @classmethod
    def parse_rfc3339(cls, s: str, /) -> Self: ...
    @classmethod
    def parse_common_iso(cls, s: str, /) -> Self: ...
    def format_common_iso(self) -> str: ...
    def exact_eq(self, other: Self, /) -> bool: ...
    def add(
        self,
        *,
        hours: float = 0,
        minutes: float = 0,
        seconds: float = 0,
        milliseconds: float = 0,
        microseconds: float = 0,
        nanoseconds: int = 0,
    ) -> Self: ...
    def subtract(
        self,
        *,
        hours: float = 0,
        minutes: float = 0,
        seconds: float = 0,
        milliseconds: float = 0,
        microseconds: float = 0,
        nanoseconds: int = 0,
    ) -> Self: ...
    def round(
        self,
        unit: _RoundUnitTime = "second",
        increment: int = 1,
        mode: _RoundMode = "half_even",
    ) -> Self: ...
    def __add__(self, delta: TimeDelta, /) -> Self: ...
    @overload
    def __sub__(self, other: _KnowsInstant, /) -> TimeDelta: ...
    @overload
    def __sub__(self, other: TimeDelta, /) -> Self: ...

@final
class OffsetDateTime(_KnowsInstantAndLocal):
    def __init__(
        self,
        year: int,
        month: int,
        day: int,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        *,
        nanosecond: int = 0,
        offset: int | TimeDelta,
    ) -> None: ...
    @classmethod
    def now(
        cls, offset: int | TimeDelta, /, *, ignore_dst: Literal[True]
    ) -> Self: ...
    @classmethod
    def from_timestamp(
        cls,
        i: int | float,
        /,
        *,
        offset: int | TimeDelta,
        ignore_dst: Literal[True],
    ) -> Self: ...
    @classmethod
    def from_timestamp_millis(
        cls, i: int, /, *, offset: int | TimeDelta, ignore_dst: Literal[True]
    ) -> Self: ...
    @classmethod
    def from_timestamp_nanos(
        cls, i: int, /, *, offset: int | TimeDelta, ignore_dst: Literal[True]
    ) -> Self: ...
    @classmethod
    def from_py_datetime(cls, d: _datetime, /) -> Self: ...
    def py_datetime(self) -> _datetime: ...
    @classmethod
    def strptime(cls, s: str, fmt: str, /) -> Self: ...
    def format_rfc2822(self) -> str: ...
    @classmethod
    def parse_rfc2822(cls, s: str, /) -> Self: ...
    def format_common_iso(self) -> str: ...
    def format_rfc3339(self) -> str: ...
    @classmethod
    def parse_rfc3339(cls, s: str, /) -> Self: ...
    @classmethod
    def parse_common_iso(cls, s: str, /) -> Self: ...
    def exact_eq(self, other: Self, /) -> bool: ...
    def replace(
        self,
        *,
        year: int = ...,
        month: int = ...,
        day: int = ...,
        hour: int = ...,
        minute: int = ...,
        second: int = ...,
        nanosecond: int = ...,
        offset: int | TimeDelta = ...,
        ignore_dst: Literal[True],
    ) -> Self: ...
    def replace_date(
        self, d: Date, /, *, ignore_dst: Literal[True]
    ) -> Self: ...
    def replace_time(
        self, t: Time, /, *, ignore_dst: Literal[True]
    ) -> Self: ...
    @overload
    def add(
        self,
        *,
        years: int = 0,
        months: int = 0,
        weeks: int = 0,
        days: int = 0,
        hours: float = 0,
        minutes: float = 0,
        seconds: float = 0,
        milliseconds: float = 0,
        microseconds: float = 0,
        nanoseconds: int = 0,
        ignore_dst: Literal[True],
    ) -> Self: ...
    @overload
    def add(self, d: Delta, /, ignore_dst: Literal[True]) -> Self: ...
    @overload
    def subtract(
        self,
        *,
        years: int = 0,
        months: int = 0,
        weeks: int = 0,
        days: int = 0,
        hours: float = 0,
        minutes: float = 0,
        seconds: float = 0,
        milliseconds: float = 0,
        microseconds: float = 0,
        nanoseconds: int = 0,
        ignore_dst: Literal[True],
    ) -> Self: ...
    @overload
    def subtract(self, d: Delta, /, ignore_dst: Literal[True]) -> Self: ...
    def round(
        self,
        unit: _RoundUnitDate = "second",
        increment: int = 1,
        mode: _RoundMode = "half_even",
        *,
        ignore_dst: Literal[True],
    ) -> Self: ...
    def __sub__(self, other: _KnowsInstant, /) -> TimeDelta: ...

@final
class ZonedDateTime(_KnowsInstantAndLocal):
    def __init__(
        self,
        year: int,
        month: int,
        day: int,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        *,
        nanosecond: int = 0,
        tz: str,
        disambiguate: _Disambiguate = ...,
    ) -> None: ...
    @property
    def tz(self) -> str: ...
    @classmethod
    def now(cls, tz: str, /) -> Self: ...
    @classmethod
    def from_py_datetime(cls, d: _datetime, /) -> Self: ...
    def py_datetime(self) -> _datetime: ...
    @classmethod
    def from_timestamp(cls, i: int | float, /, *, tz: str) -> Self: ...
    @classmethod
    def from_timestamp_millis(cls, i: int, /, *, tz: str) -> Self: ...
    @classmethod
    def from_timestamp_nanos(cls, i: int, /, *, tz: str) -> Self: ...
    def format_common_iso(self) -> str: ...
    @classmethod
    def parse_common_iso(cls, s: str, /) -> Self: ...
    def exact_eq(self, other: Self, /) -> bool: ...
    def replace(
        self,
        *,
        year: int = ...,
        month: int = ...,
        day: int = ...,
        hour: int = ...,
        minute: int = ...,
        second: int = ...,
        nanosecond: int = ...,
        tz: str = ...,
        disambiguate: _Disambiguate = ...,
    ) -> Self: ...
    def replace_date(
        self, d: Date, /, *, disambiguate: _Disambiguate = ...
    ) -> Self: ...
    def replace_time(
        self, t: Time, /, *, disambiguate: _Disambiguate = ...
    ) -> Self: ...
    @overload
    def add(
        self,
        *,
        years: int = 0,
        months: int = 0,
        weeks: int = 0,
        days: int = 0,
        hours: float = 0,
        minutes: float = 0,
        seconds: float = 0,
        milliseconds: float = 0,
        microseconds: float = 0,
        nanoseconds: int = 0,
        disambiguate: _Disambiguate = ...,
    ) -> Self: ...
    # FUTURE: include this in strict stubs version
    # @overload
    # def add(
    #     self,
    #     *,
    #     hours: float = 0,
    #     minutes: float = 0,
    #     seconds: float = 0,
    #     milliseconds: float = 0,
    #     microseconds: float = 0,
    #     nanoseconds: int = 0,
    # ) -> Self: ...
    @overload
    def add(self, d: TimeDelta, /) -> ZonedDatSelfeTime: ...
    @overload
    def add(
        self,
        d: DateDelta | DateTimeDelta,
        /,
        *,
        disambiguate: _Disambiguate = ...,
    ) -> Self: ...
    @overload
    def subtract(
        self,
        *,
        years: int = 0,
        months: int = 0,
        weeks: int = 0,
        days: int = 0,
        hours: float = 0,
        minutes: float = 0,
        seconds: float = 0,
        milliseconds: float = 0,
        microseconds: float = 0,
        nanoseconds: int = 0,
        disambiguate: _Disambiguate = ...,
    ) -> Self: ...
    # FUTURE: include this in strict stubs version
    # @overload
    # def subtract(
    #     self,
    #     *,
    #     hours: float = 0,
    #     minutes: float = 0,
    #     seconds: float = 0,
    #     milliseconds: float = 0,
    #     microseconds: float = 0,
    #     nanoseconds: int = 0,
    # ) -> Self: ...
    @overload
    def subtract(self, d: TimeDelta, /) -> Self: ...
    @overload
    def subtract(
        self,
        d: DateDelta | DateTimeDelta,
        /,
        *,
        disambiguate: _Disambiguate = ...,
    ) -> Self: ...
    def is_ambiguous(self) -> bool: ...
    def hours_in_day(self) -> float: ...
    def start_of_day(self) -> Self: ...
    def round(
        self,
        unit: _RoundUnitDate = "second",
        increment: int = 1,
        mode: _RoundMode = "half_even",
    ) -> Self: ...
    # FUTURE: disable date components in strict stubs version
    def __add__(self, delta: Delta, /) -> Self: ...
    @overload
    def __sub__(self, other: _KnowsInstant, /) -> TimeDelta: ...
    @overload
    def __sub__(self, other: Delta, /) -> Self: ...

@final
class SystemDateTime(_KnowsInstantAndLocal):
    def __init__(
        self,
        year: int,
        month: int,
        day: int,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        *,
        nanosecond: int = 0,
        disambiguate: _Disambiguate = ...,
    ) -> None: ...
    @classmethod
    def now(cls) -> Self: ...
    @classmethod
    def from_timestamp(cls, i: int | float, /) -> Self: ...
    @classmethod
    def from_timestamp_millis(cls, i: int, /) -> Self: ...
    @classmethod
    def from_timestamp_nanos(cls, i: int, /) -> Self: ...
    @classmethod
    def from_py_datetime(cls, d: _datetime, /) -> Self: ...
    def py_datetime(self) -> _datetime: ...
    @classmethod
    def parse_common_iso(cls, s: str, /) -> Self: ...
    def format_common_iso(self) -> str: ...
    def exact_eq(self, other: Self, /) -> bool: ...
    def replace(
        self,
        *,
        year: int = ...,
        month: int = ...,
        day: int = ...,
        hour: int = ...,
        minute: int = ...,
        second: int = ...,
        nanosecond: int = ...,
        disambiguate: _Disambiguate = ...,
    ) -> Self: ...
    def replace_date(
        self, d: Date, /, *, disambiguate: _Disambiguate = ...
    ) -> Self: ...
    def replace_time(
        self, t: Time, /, *, disambiguate: _Disambiguate = ...
    ) -> Self: ...
    @overload
    def add(
        self,
        *,
        years: int = 0,
        months: int = 0,
        weeks: int = 0,
        days: int = 0,
        hours: float = 0,
        minutes: float = 0,
        seconds: float = 0,
        milliseconds: float = 0,
        microseconds: float = 0,
        nanoseconds: int = 0,
        disambiguate: _Disambiguate = ...,
    ) -> Self: ...
    # FUTURE: include this in strict stubs version
    # @overload
    # def add(
    #     self,
    #     *,
    #     hours: float = 0,
    #     minutes: float = 0,
    #     seconds: float = 0,
    #     milliseconds: float = 0,
    #     microseconds: float = 0,
    #     nanoseconds: int = 0,
    # ) -> Self: ...
    @overload
    def add(self, d: TimeDelta, /) -> Self: ...
    @overload
    def add(
        self,
        d: DateDelta | DateTimeDelta,
        /,
        *,
        disambiguate: _Disambiguate = ...,
    ) -> Self: ...
    @overload
    def subtract(
        self,
        *,
        years: int = 0,
        months: int = 0,
        weeks: int = 0,
        days: int = 0,
        hours: float = 0,
        minutes: float = 0,
        seconds: float = 0,
        milliseconds: float = 0,
        microseconds: float = 0,
        nanoseconds: int = 0,
        disambiguate: _Disambiguate = ...,
    ) -> Self: ...
    # FUTURE: include this in strict stubs version
    # @overload
    # def subtract(
    #     self,
    #     *,
    #     hours: float = 0,
    #     minutes: float = 0,
    #     seconds: float = 0,
    #     milliseconds: float = 0,
    #     microseconds: float = 0,
    #     nanoseconds: int = 0,
    # ) -> Self: ...
    @overload
    def subtract(self, d: TimeDelta, /) -> Self: ...
    @overload
    def subtract(
        self,
        d: DateDelta | DateTimeDelta,
        /,
        *,
        disambiguate: _Disambiguate = ...,
    ) -> Self: ...
    def is_ambiguous(self) -> bool: ...
    def hours_in_day(self) -> float: ...
    def start_of_day(self) -> ZonedDateTime: ...
    def round(
        self,
        unit: _RoundUnitDate = "second",
        increment: int = 1,
        mode: _RoundMode = "half_even",
    ) -> Self: ...
    # FUTURE: disable date components in strict stubs version
    def __add__(self, delta: Delta, /) -> Self: ...
    @overload
    def __sub__(self, other: _KnowsInstant, /) -> TimeDelta: ...
    @overload
    def __sub__(self, other: Delta, /) -> Self: ...

@final
class LocalDateTime(_KnowsLocal):
    def __init__(
        self,
        year: int,
        month: int,
        day: int,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        *,
        nanosecond: int = 0,
    ) -> None: ...
    MIN: ClassVar[Self]
    MAX: ClassVar[Self]
    def assume_utc(self) -> Instant: ...
    def assume_fixed_offset(
        self, offset: int | TimeDelta, /
    ) -> OffsetDateTime: ...
    def assume_tz(
        self, tz: str, /, *, disambiguate: _Disambiguate = ...
    ) -> ZonedDateTime: ...
    def assume_system_tz(
        self, *, disambiguate: _Disambiguate = ...
    ) -> SystemDateTime: ...
    @classmethod
    def from_py_datetime(cls, d: _datetime, /) -> Self: ...
    def py_datetime(self) -> _datetime: ...
    @classmethod
    def parse_common_iso(cls, s: str, /) -> Self: ...
    def format_common_iso(self) -> str: ...
    @classmethod
    def strptime(cls, s: str, fmt: str, /) -> Self: ...
    def replace(
        self,
        *,
        year: int = ...,
        month: int = ...,
        day: int = ...,
        hour: int = ...,
        minute: int = ...,
        second: int = ...,
        nanosecond: int = ...,
    ) -> Self: ...
    def replace_date(self, d: Date, /) -> Self: ...
    def replace_time(self, t: Time, /) -> Self: ...
    @overload
    def add(
        self,
        *,
        years: int = 0,
        months: int = 0,
        weeks: int = 0,
        days: int = 0,
        hours: float = 0,
        minutes: float = 0,
        seconds: float = 0,
        milliseconds: float = 0,
        microseconds: float = 0,
        nanoseconds: int = 0,
        ignore_dst: Literal[True],
    ) -> Self: ...
    @overload
    def add(
        self, *, years: int = 0, months: int = 0, weeks: int = 0, days: int = 0
    ) -> Self: ...
    @overload
    def add(self, d: DateDelta, /) -> Self: ...
    @overload
    def add(
        self, d: TimeDelta | DateTimeDelta, /, *, ignore_dst: Literal[True]
    ) -> Self: ...
    @overload
    def subtract(
        self,
        *,
        years: int = 0,
        months: int = 0,
        weeks: int = 0,
        days: int = 0,
        hours: float = 0,
        minutes: float = 0,
        seconds: float = 0,
        milliseconds: float = 0,
        microseconds: float = 0,
        nanoseconds: int = 0,
        ignore_dst: Literal[True],
    ) -> Self: ...
    @overload
    def subtract(
        self, *, years: int = 0, months: int = 0, weeks: int = 0, days: int = 0
    ) -> Self: ...
    @overload
    def subtract(self, d: DateDelta, /) -> Self: ...
    @overload
    def subtract(
        self, d: TimeDelta | DateTimeDelta, /, *, ignore_dst: Literal[True]
    ) -> Self: ...
    def difference(
        self, other: Self, /, *, ignore_dst: Literal[True]
    ) -> TimeDelta: ...
    def round(
        self,
        unit: _RoundUnitDate = "second",
        increment: int = 1,
        mode: _RoundMode = "half_even",
    ) -> Self: ...
    def __add__(self, delta: DateDelta, /) -> Self: ...
    def __sub__(self, other: DateDelta, /) -> Self: ...
    def __lt__(self, other: Self, /) -> bool: ...
    def __le__(self, other: Self, /) -> bool: ...
    def __gt__(self, other: Self, /) -> bool: ...
    def __ge__(self, other: Self, /) -> bool: ...

@final
class RepeatedTime(Exception): ...

@final
class SkippedTime(Exception): ...

@final
class InvalidOffset(ValueError): ...

@final
class ImplicitlyIgnoringDST(TypeError): ...

class Weekday(enum.Enum):
    MONDAY = 1
    TUESDAY = 2
    WEDNESDAY = 3
    THURSDAY = 4
    FRIDAY = 5
    SATURDAY = 6
    SUNDAY = 7

MONDAY = Weekday.MONDAY
TUESDAY = Weekday.TUESDAY
WEDNESDAY = Weekday.WEDNESDAY
THURSDAY = Weekday.THURSDAY
FRIDAY = Weekday.FRIDAY
SATURDAY = Weekday.SATURDAY
SUNDAY = Weekday.SUNDAY

def years(i: int, /) -> DateDelta: ...
def months(i: int, /) -> DateDelta: ...
def weeks(i: int, /) -> DateDelta: ...
def days(i: int, /) -> DateDelta: ...
def hours(i: float, /) -> TimeDelta: ...
def minutes(i: float, /) -> TimeDelta: ...
def seconds(i: float, /) -> TimeDelta: ...
def milliseconds(i: float, /) -> TimeDelta: ...
def microseconds(i: float, /) -> TimeDelta: ...
def nanoseconds(i: int, /) -> TimeDelta: ...

class _TimePatch:
    def shift(self, *args: Any, **kwargs: Any) -> None: ...

@contextmanager
def patch_current_time(
    i: _KnowsInstant, /, *, keep_ticking: bool
) -> Iterator[_TimePatch]: ...
